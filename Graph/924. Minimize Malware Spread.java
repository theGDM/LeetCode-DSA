//Now in this question we, are going to use Disjoint union set
//We will first apply the union on the nodes, which are nbrs of each other.
//Then we will count the number of the infected nodes, in each individual set, in malwareCount array
//As we need to minimize the malware spread, we need to identify the set, having only one infected node, and also it
//having large size. So if we remove that node, all the nodes belonging to that particular set will be saved from infection.
class Solution {
    int[] rank;
    int[] parent;
    public int minMalwareSpread(int[][] graph, int[] initial) {
        rank = new int[graph.length];
        parent = new int[graph.length];
        
        for(int i = 0;i < graph.length; ++i){
            parent[i] = i;
            rank[i] = 0;
        }
        
        for(int i = 0; i < graph.length; ++i){
            for(int j = 0; j < graph.length; ++j){
                if(i != j && graph[i][j] == 1){
                    unionHelper(i, j);
                }
            }
        }
        
        int[] malwareCount = new int[graph.length];
        
        for(int infV : initial){
            int sl = find(infV);
            malwareCount[sl]++;
        }
        
        Arrays.sort(initial);//nlogn
        
        int sizeOfInfectedNode = Integer.MIN_VALUE;
        int mNode = initial[0];
        
        for(int infV : initial){
            int sl = find(infV);
            if(malwareCount[sl] == 1){
                int size = 0;
                for(int i = 0;i < graph.length; ++i){ //getting size of set whose parent is set lead
                    if(parent[i] == sl){
                        ++size;
                    }
                }
                
                if(size > sizeOfInfectedNode){
                  sizeOfInfectedNode = size;
                  mNode = infV;
               }
            } 
        }
        
        return mNode;
    }
    
    public int find(int x){
        if(parent[x] == x){
            return x;
        }else{
            parent[x] = find(parent[x]);
            return parent[x];
        }
    }
    
    public void unionHelper(int x, int y){
        int xl = find(x);
        int yl = find(y);
        
        if(xl != yl){
            if(rank[xl] < rank[yl]){
                parent[xl] = yl;
            }else if(rank[yl] < rank[xl]){
                parent[yl] = xl;
            }else{
                parent[xl] = yl;
                rank[yl]++;
            }
        }
    }
}
